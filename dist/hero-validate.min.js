(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["HeroValidate"] = factory();
	else
		root["HeroValidate"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 572:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "extend": () => (/* binding */ extend),
  "formatErrors": () => (/* binding */ formatErrors),
  "formatMessage": () => (/* binding */ formatMessage),
  "getEmpty": () => (/* binding */ getEmpty),
  "languages": () => (/* reexport */ languages),
  "setDefaultMessage": () => (/* reexport */ setDefaultMessage),
  "setLocale": () => (/* reexport */ setLocale),
  "setMessages": () => (/* reexport */ setMessages),
  "setParamsSeparator": () => (/* reexport */ setParamsSeparator),
  "setRuleParamSeparator": () => (/* reexport */ setRuleParamSeparator),
  "setRuleSeparator": () => (/* reexport */ setRuleSeparator),
  "validate": () => (/* binding */ validate)
});

// EXTERNAL MODULE: ./src/lang/en.js
var en = __webpack_require__(143);
var en_default = /*#__PURE__*/__webpack_require__.n(en);
// EXTERNAL MODULE: ./src/lang/vi.js
var vi = __webpack_require__(514);
var vi_default = /*#__PURE__*/__webpack_require__.n(vi);
;// CONCATENATED MODULE: ./src/messages.js

let languages  = {
    // /**
    //  * lang for Arabic.
    //  */
    // ar : "ar",
    // /**
    //  * lang for Azeri.
    //  */
    // az : "az",
    // /**
    //  * lang for Belarusian.
    //  */
    // be : "be",
    // /**
    //  * lang for Bulgarian.
    //  */
    // bg : "bg",
    // /**
    //  * lang for Bosnian.
    //  */
    // bs : "bs",
    // /**
    //  * lang for Catalan.
    //  */
    // ca : "ca",
    // /**
    //  * lang for Czech.
    //  */
    // cs : "cs",
    // /**
    //  * lang for Welsh.
    //  */
    // cy : "cy",
    // /**
    //  * lang for Danish.
    //  */
    // da : "da",
    // /**
    //  * lang for German.
    //  */
    // de : "de",
    // /**
    //  * lang for Greek.
    //  */
    // el : "el",
    // /**
    //  * lang for English.
    //  */
    en : "en",
    // /**
    //  * lang for Spanish.
    //  */
    // es : "es",
    // /**
    //  * lang for Estonian.
    //  */
    // et : "et",
    // /**
    //  * lang for Basque.
    //  */
    // eu : "eu",
    // /**
    //  * lang for Farsi.
    //  */
    // fa : "fa",
    // /**
    //  * lang for Finnish.
    //  */
    // fi : "fi",
    // /**
    //  * lang for French.
    //  */
    // fr : "fr",
    // /**
    //  * lang for Croatian.
    //  */
    // hr : "hr",
    // /**
    //  * lang for Hungarian.
    //  */
    // hu : "hu",
    // /**
    //  * lang for Indonesian.
    //  */
    // id : "id",
    // /**
    //  * lang for Italian - Switzerland.
    //  */
    // it : "it",
    // /**
    //  * lang for Japanese.
    //  */
    // ja : "ja",
    // /**
    //  * lang for Georgian.
    //  */
    // ka : "ka",
    // /**
    //  * lang for Korean.
    //  */
    // ko : "ko",
    // /**
    //  * lang for Italian - Italy.
    //  */
    // It : "It",
    // Iv : "Iv",
    // /**
    //  * lang for FYRO Macedonia.
    //  */
    // mk : "mk",
    // /**
    //  * lang for Mongolian.
    //  */
    // mn : "mn",
    // /**
    //  * lang for Malay.
    //  */
    // ms : "ms",
    // /**
    //  * lang for Norwegian - Bokml.
    //  */
    // nb_NO : "nb_NO",
    // /**
    //  * lang for Dutch.
    //  */
    // nl : "nl",
    // /**
    //  * lang for Polish.
    //  */
    // pl : "pl",
    // /**
    //  * lang for Portuguese - Portugal.
    //  */
    // pt : "pt",
    // /**
    //  * lang for Portuguese - Brazil.
    //  */
    // pt_BR : "pt_BR",
    // /**
    //  * lang for Romanian.
    //  */
    // ro : "ro",
    // /**
    //  * lang for Russian.
    //  */
    // ru : "ru",
    // se : "se",
    // /**
    //  * lang for Slovenian.
    //  */
    // sl : "sl",
    // /**
    //  * lang for Albanian.
    //  */
    // sq : "sq",
    // /**
    //  * lang for Serbian.
    //  */
    // sr : "sr",
    // /**
    //  * lang for Swedish.
    //  */
    // sv : "sv",
    // /**
    //  * lang for Turkish.
    //  */
    // tr : "tr",
    // ua : "ua",
    // /**
    //  * lang for Ukrainian.
    //  */
    // uk : "uk",
    // /**
    //  * lang for Vietnamese.
    //  */
    vi : "vi",
    // /**
    //  * lang for Chinese.
    //  */
    // zh : "zh",
    // /**
    //  * lang for Chinese - Taiwan.
    //  */
    // zh_TW : "zh_TW",
}


/**
 * @type {string}
 */
let defaultMessage = 'Incorrect Value';
let defaultLocale = 'en';

/**
 * @type {*}
 */



let LANG_MESS = []
LANG_MESS[`${languages.en}`] = (en_default())
LANG_MESS[`${languages.vi}`] = (vi_default())

let messages = LANG_MESS[`${languages.en}`]


/**
 * @param {object} Message set ... 
 */
function setMessages(m) {
    if (typeof m !== 'object') {
        throw 'Messages must be object';
    }

    messages = { ...messages, ...m };
}

/**
 * @param {string} msg
 */
function setDefaultMessage(msg) {
    if (typeof msg !== 'string') {
        throw 'Default message must be a string';
    }

    defaultMessage = msg;
}


/**
 * @param {object} Message set ... 
 */
 function setLocale( locale = 'en' ) {
    if (typeof locale !== 'string') {
        throw 'Locale must be string';
    }

    defaultLocale = locale
    if( typeof LANG_MESS[locale] === undefined ){
        throw `Locale - ${locale} is not supported`;
    }
    messages = { ...messages, ...LANG_MESS[locale] };
}



;// CONCATENATED MODULE: ./src/methods.js
const emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

let methods = {
    /**
     * @param value
     * @return {boolean|{value}}
     */
    alpha(value) {
        return /^[a-zA-Z]+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    alpha_dash(value) {
        return /^[A-Za-z\-]+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    alpha_numeric(value) {
        return /^[A-Za-z0-9]+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{}}
     */
    array(value) {
        return Array.isArray(value) || {};
    },

    /**
     * @param value
     * @param from
     * @param to
     * @return {{from, to, value}|boolean}
     */
    between(value, from, to) {
        if (typeof value === 'string') {
            if (value.length >= from && value.length <= to) {
                return true;
            }
        } else {
            if (value >= from && value <= to) {
                return true;
            }
        }
        return { from, to, value };
    },

    /**
     * @param value
     * @return {boolean}
     */
    boolean(value) {
        return typeof value === 'boolean' || {};
    },

    /**
     * @param value
     * @return {boolean}
     */
    checked(value) {
        return (
            value === 1 || value === 'on' || value === true || value === 'true' || {}
        );
    },

    /**
     * @param value
     * @param values
     * @return {{value_to_contain: *}|boolean}
     */
    contains_all(value, ...values) {
        if (!Array.isArray(value)) {
            value = String(value);
        }
        for (let i = 0, l = values.length; i < l; i++) {
            if (value.indexOf(values[i]) === -1) {
                return { value_to_contain: values[i] };
            }
        }
        return true;
    },

    /**
     * @param value
     * @param values
     * @return {boolean|{value_to_contain: string}}
     */
    contains_one(value, ...values) {
        if (!Array.isArray(value)) {
            value = String(value);
        }
        for (let i = 0, l = values.length; i < l; i++) {
            if (value.indexOf(values[i]) > -1) {
                return true;
            }
        }
        return { value_to_contain: values.join(',') };
    },

    /**
     * @param value
     * @return {boolean}
     */
    date(value) {
        return !isNaN(Date.parse(value)) || {};
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    email(value) {
        return emailRegex.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    phone(value) {
        value = String(value);
        return /^\d{7,}$/.test(value.replace(/[\s()+\-\.]|ext/gi, '')) || { value };
    },

    /**
     * @param value
     * @param suffix
     * @return {boolean|{suffix: string}}
     */
    ends_with(value, suffix) {
        suffix = String(suffix);
        value = String(value);
        return (
            value.indexOf(suffix, value.length - suffix.length) !== -1 || { suffix }
        );
    },

    /**
     * @param value
     * @param param
     * @return {boolean|{value}}
     */
    equals(value, param) {
        return String(value) === String(param) || { value: param };
    },

    /**
     * @param value
     * @param arr
     * @return {boolean|{value: string}}
     */
    in_array(value, ...arr) {
        return arr.indexOf(String(value)) > -1 || { value: arr.join(',') };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    ip(value) {
        return ipRegex.test(value) || { value };
    },

    /**
     * @param value
     * @return {{}|boolean}
     */
    json(value) {
        try {
            JSON.parse(String(value));
            return true;
        } catch (e) {
            return {};
        }
    },

    /**
     * @param value
     * @param max
     * @return {{max}|boolean}
     */
    max(value, max) {
        if (typeof value === 'string') {
            if (value.length <= max) return true;
        } else if (typeof value !== undefined) {
            if (value <= max) return true;
        }
        return { max };
    },

    /**
     * @param value
     * @param min
     * @return {{min}|boolean}
     */
    min(value, min) {
        if (typeof value === 'string') {
            if (value.length >= min) return true;
        } else if (typeof value !== undefined) {
            if (value >= min) return true;
        }
        return { min };
    },

    /**
     * @param value
     * @param param
     * @return {boolean|{value}}
     */
    not_equals(value, param) {
        return String(value) !== String(param) || { value: param };
    },

    /**
     * @param value
     * @param arr
     * @return {boolean|{value}}
     */
    not_in(value, ...arr) {
        return arr.indexOf(String(value)) === -1 || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    numeric(value) {
        return /^-?\d+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    object(value) {
        return (typeof value === 'object' && !Array.isArray(value)) || { value };
    },

    /**
     * @param value
     * @param prefix
     * @return {boolean|{prefix: string}}
     */
    starts_with(value, prefix) {
        prefix = String(prefix);
        value = String(value);
        return value.indexOf(prefix) === 0 || { prefix };
    },

    /**
     * @param value
     * @return {{value}|boolean}
     */
    url(value) {
        try {
            new URL(value);
            return true;
        } catch (e) {
            return { value };
        }
    },
};

/**
 * @param {string} name
 * @returns {function}
 */
function getValidationMethod(name) {
    if (methods.hasOwnProperty(name) === false) {
        throw `The validation method "${name}" does not exist`;
    }
    return methods[name];
}




// var rules = {
//     required: function (val) {
//         var str;

//         if (val === undefined || val === null) {
//             return false;
//         }

//         str = String(val).replace(/\s/g, "");
//         return str.length > 0 ? true : false;
//     },

//     required_if: function (val, req, attribute) {
//         req = this.getParameters();
//         if (this.validator._objectPath(this.validator.input, req[0]) === req[1]) {
//             return this.validator.getRule("required").validate(val);
//         }

//         return true;
//     },

//     required_unless: function (val, req, attribute) {
//         req = this.getParameters();
//         if (this.validator._objectPath(this.validator.input, req[0]) !== req[1]) {
//             return this.validator.getRule("required").validate(val);
//         }

//         return true;
//     },

//     required_with: function (val, req, attribute) {
//         if (this.validator._objectPath(this.validator.input, req)) {
//             return this.validator.getRule("required").validate(val);
//         }

//         return true;
//     },

//     required_with_all: function (val, req, attribute) {
//         req = this.getParameters();

//         for (var i = 0; i < req.length; i++) {
//             if (!this.validator._objectPath(this.validator.input, req[i])) {
//                 return true;
//             }
//         }

//         return this.validator.getRule("required").validate(val);
//     },

//     required_without: function (val, req, attribute) {
//         if (this.validator._objectPath(this.validator.input, req)) {
//             return true;
//         }

//         return this.validator.getRule("required").validate(val);
//     },

//     required_without_all: function (val, req, attribute) {
//         req = this.getParameters();

//         for (var i = 0; i < req.length; i++) {
//             if (this.validator._objectPath(this.validator.input, req[i])) {
//                 return true;
//             }
//         }

//         return this.validator.getRule("required").validate(val);
//     },

//     boolean: function (val) {
//         return (
//             val === true ||
//             val === false ||
//             val === 0 ||
//             val === 1 ||
//             val === "0" ||
//             val === "1" ||
//             val === "true" ||
//             val === "false"
//         );
//     },

//     // compares the size of strings
//     // with numbers, compares the value
//     size: function (val, req, attribute) {
//         if (val) {
//             req = parseFloat(req);

//             var size = this.getSize();

//             return size === req;
//         }

//         return true;
//     },

//     string: function (val, req, attribute) {
//         return typeof val === "string";
//     },

//     sometimes: function (val) {
//         return true;
//     },

//     /**
//      * Compares the size of strings or the value of numbers if there is a truthy value
//      */
//     min: function (val, req, attribute) {
//         var size = this.getSize();
//         return size >= req;
//     },

//     /**
//      * Compares the size of strings or the value of numbers if there is a truthy value
//      */
//     max: function (val, req, attribute) {
//         var size = this.getSize();
//         return size <= req;
//     },

//     between: function (val, req, attribute) {
//         req = this.getParameters();
//         var size = this.getSize();
//         var min = parseFloat(req[0], 10);
//         var max = parseFloat(req[1], 10);
//         return size >= min && size <= max;
//     },

//     email: function (val) {
//         // Added umlaut support https://github.com/skaterdav85/validatorjs/issues/308
//         var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
//         if (!re.test(val)) {
//             // added support domain 3-n level https://github.com/skaterdav85/validatorjs/issues/384
//             re = /^((?:[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]|[^\u0000-\u007F])+@(?:[a-zA-Z0-9]|[^\u0000-\u007F])(?:(?:[a-zA-Z0-9-]|[^\u0000-\u007F]){0,61}(?:[a-zA-Z0-9]|[^\u0000-\u007F]))?(?:\.(?:[a-zA-Z0-9]|[^\u0000-\u007F])(?:(?:[a-zA-Z0-9-]|[^\u0000-\u007F]){0,61}(?:[a-zA-Z0-9]|[^\u0000-\u007F]))?)+)*$/;
//         }
//         return re.test(val);
//     },

//     numeric: function (val) {
//         var num;

//         num = Number(val); // tries to convert value to a number. useful if value is coming from form element

//         if (typeof num === "number" && !isNaN(num) && typeof val !== "boolean") {
//             return true;
//         } else {
//             return false;
//         }
//     },

//     array: function (val) {
//         return val instanceof Array;
//     },

//     url: function (url) {
//         return /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_\+.~#?&/=]*)/i.test(url);
//     },

//     alpha: function (val) {
//         return /^[a-zA-Z]+$/.test(val);
//     },

//     alpha_dash: function (val) {
//         return /^[a-zA-Z0-9_\-]+$/.test(val);
//     },

//     alpha_num: function (val) {
//         return /^[a-zA-Z0-9]+$/.test(val);
//     },

//     same: function (val, req) {
//         var val1 = this.validator._flattenObject(this.validator.input)[req];
//         var val2 = val;

//         if (val1 === val2) {
//             return true;
//         }

//         return false;
//     },

//     different: function (val, req) {
//         var val1 = this.validator._flattenObject(this.validator.input)[req];
//         var val2 = val;

//         if (val1 !== val2) {
//             return true;
//         }

//         return false;
//     },

//     in: function (val, req) {
//         var list, i;

//         if (val) {
//             list = this.getParameters();
//         }

//         if (val && !(val instanceof Array)) {
//             var localValue = val;

//             for (i = 0; i < list.length; i++) {
//                 if (typeof list[i] === "string") {
//                     localValue = String(val);
//                 }

//                 if (localValue === list[i]) {
//                     return true;
//                 }
//             }

//             return false;
//         }

//         if (val && val instanceof Array) {
//             for (i = 0; i < val.length; i++) {
//                 if (list.indexOf(val[i]) < 0) {
//                     return false;
//                 }
//             }
//         }

//         return true;
//     },

//     not_in: function (val, req) {
//         var list = this.getParameters();
//         var len = list.length;
//         var returnVal = true;

//         for (var i = 0; i < len; i++) {
//             var localValue = val;

//             if (typeof list[i] === "string") {
//                 localValue = String(val);
//             }

//             if (localValue === list[i]) {
//                 returnVal = false;
//                 break;
//             }
//         }

//         return returnVal;
//     },

//     accepted: function (val) {
//         if (val === "on" || val === "yes" || val === 1 || val === "1" || val === true) {
//             return true;
//         }

//         return false;
//     },

//     confirmed: function (val, req, key) {
//         var confirmedKey = key + "_confirmation";

//         if (this.validator.input[confirmedKey] === val) {
//             return true;
//         }

//         return false;
//     },

//     integer: function (val) {
//         return String(parseInt(val, 10)) === String(val);
//     },

//     digits: function (val, req) {
//         var numericRule = this.validator.getRule('numeric');
//         if (numericRule.validate(val) && String(val.trim()).length === parseInt(req)) {
//             return true;
//         }

//         return false;
//     },

//     digits_between: function (val) {
//         var numericRule = this.validator.getRule("numeric");
//         var req = this.getParameters();
//         var valueDigitsCount = String(val).length;
//         var min = parseFloat(req[0], 10);
//         var max = parseFloat(req[1], 10);

//         if (numericRule.validate(val) && valueDigitsCount >= min && valueDigitsCount <= max) {
//             return true;
//         }

//         return false;
//     },

//     regex: function (val, req) {
//         let reqPattern = req;
//         var mod = /[g|i|m]{1,3}$/;
//         var flag = req.match(mod);
//         flag = flag ? flag[0] : "";

//         req = req.replace(mod, "").slice(1, -1);
//         req = new RegExp(req, flag);
//         return !!req.test(val);
//     },

//     date: function (val, format) {
//         return isValidDate(val);
//     },

//     present: function (val) {
//         return typeof val !== "undefined";
//     },

//     after: function (val, req) {
//         var val1 = this.validator.input[req];
//         var val2 = val;

//         if (!isValidDate(val1)) {
//             return false;
//         }
//         if (!isValidDate(val2)) {
//             return false;
//         }

//         if (new Date(val1).getTime() < new Date(val2).getTime()) {
//             return true;
//         }

//         return false;
//     },

//     after_or_equal: function (val, req) {
//         var val1 = this.validator.input[req];
//         var val2 = val;

//         if (!isValidDate(val1)) {
//             return false;
//         }
//         if (!isValidDate(val2)) {
//             return false;
//         }

//         if (new Date(val1).getTime() <= new Date(val2).getTime()) {
//             return true;
//         }

//         return false;
//     },

//     before: function (val, req) {
//         var val1 = this.validator.input[req];
//         var val2 = val;

//         if (!isValidDate(val1)) {
//             return false;
//         }
//         if (!isValidDate(val2)) {
//             return false;
//         }

//         if (new Date(val1).getTime() > new Date(val2).getTime()) {
//             return true;
//         }

//         return false;
//     },

//     before_or_equal: function (val, req) {
//         var val1 = this.validator.input[req];
//         var val2 = val;

//         if (!isValidDate(val1)) {
//             return false;
//         }
//         if (!isValidDate(val2)) {
//             return false;
//         }

//         if (new Date(val1).getTime() >= new Date(val2).getTime()) {
//             return true;
//         }

//         return false;
//     },

//     hex: function (val) {
//         return /^[0-9a-f]+$/i.test(val);
//     },

//     ipv4: function (val, req, attribute) {
//         if (typeof val != 'string')
//             return false;

//         // regex to check that each octet is valid
//         var er = /^[0-9]+$/;
//         // ipv4 octets are delimited by dot
//         octets = val.split('.');
//         // check 1: ipv4 address should contains 4 octets
//         if (octets.length != 4)
//             return false;

//         for (let i = 0; i < octets.length; i++) {
//             const element = octets[i];
//             // check 2: each octet should be integer bigger than 0
//             if (!er.test(element))
//                 return false;

//             // check 3: each octet value should be less than 256
//             var octetValue = parseInt(element);
//             if (octetValue >= 256)
//                 return false;
//         }

//         // if all checks passed, we know it's valid IPv4 address!
//         return true;
//     },

//     ipv6: function (val, req, attribute) {
//         if (typeof val != 'string')
//             return false;

//         // regex to check that each hextet is valid
//         var er = /^[0-9a-f]+$/;
//         // ipv6 hextets are delimited by colon
//         hextets = val.split(':');

//         // check 1: ipv6 should contain only one consecutive colons
//         colons = val.match(/::/);
//         if (colons != null && val.match(/::/g).length > 1)
//             return false;

//         // check 2: ipv6 should not be ending or starting with colon
//         //          edge case: not with consecutive colons
//         if (val[0] == ':' && (colons == null || (colons != null && colons.index != 0)))
//             return false;
//         if (val[val.length - 1] == ':' && (colons == null || (colons != null && colons.index != val.length - 2)))
//             return false;

//         // check 3: ipv6 should contain no less than 3 sector
//         //         minimum ipv6 addres - ::1
//         if (3 > hextets.length)
//             return false;

//         // check 4: ipv6 should contain no more than 8 sectors
//         //         only 1 edge case: when first or last sector is ommited
//         var isEdgeCase = (hextets.length == 9 && colons != null && (colons.index == 0 || colons.index == val.length - 2));
//         if (hextets.length > 8 && !isEdgeCase)
//             return false;

//         // check 5: ipv6 should contain exactly one consecutive colons if it has less than 8 sectors
//         if (hextets.length != 8 && colons == null)
//             return false;

//         for (let i = 0; i < hextets.length; i++) {
//             const element = hextets[i];

//             if (element.length == 0)
//                 continue;

//             // check 6: all of hextets should contain numbers from 0 to f (in hexadecimal)
//             if (!er.test(element))
//                 return false;

//             // check 7: all of hextet values should be less then ffff (in hexadeimal)
//             //          checking using length of hextet. lowest invalid value's length is 5.
//             //          so all valid hextets are length of 4 or less
//             if (element.length > 4)
//                 return false;
//         }
//         return true;
//     },

//     ip: function (val, req, attribute) {
//         return rules['ipv4'](val, req, attribute) || rules['ipv6'](val, req, attribute);
//     }

// };
;// CONCATENATED MODULE: ./src/Rule.js


const dontValidate = ['required', 'string', 'nullable', 'number'];

let ruleSeparator = '|';
let ruleParamSeparator = ':';
let paramsSeparator = ',';

/**
 * Override default rule separator
 * @param {string} separator
 */
function setRuleSeparator(separator) {
    if (typeof separator !== 'string') {
        throw 'Separator must be string';
    }
    ruleSeparator = separator;
}

/**
 * Override default rule-params separator
 * @param {string} separator
 */
function setRuleParamSeparator(separator) {
    if (typeof separator !== 'string') {
        throw 'Separator must be string';
    }
    ruleParamSeparator = separator;
}

/**
 * Override default params separator
 * @param {string} separator
 */
function setParamsSeparator(separator) {
    if (typeof separator !== 'string') {
        throw 'Separator must be string';
    }
    paramsSeparator = separator;
}

/**
 * @class Rule
 * @param {string} rule
 */
class Rule {
    /**
     * @param {string|function} rule
     */
    constructor(rule) {
        if (typeof rule === 'string') {
            this.name = rule;
            this.isInlineFunction = false;
            if (dontValidate.indexOf(rule) === -1) {
                this.validator = getValidationMethod(this.name);
            }
        } else if (typeof rule === 'function') {
            this.name = rule.name || 'default';
            this.isInlineFunction = true;
            this.validator = rule;
        }

        this.params = [];
    }

    /**
     * @param {{}} rules
     * @param {*} value
     * @param {{}} data
     * @return {{rule: string}|boolean|*}
     */
    validate(rules, value, data) {
        if (value === undefined || value === null || value === '') {
            if (rules.isRequired) {
                return { rule: 'required' };
            } else if (rules.isNullable) {
                return true;
            }
        }

        if (rules.isNumber) {
            value = parseFloat(value);
        } else if (rules.isString) {
            value = String(value);
        }

        if (this.isInlineFunction) {
            return this.validator(value, data);
        } else {
            return this.validator(value, ...this.params);
        }
    }

    /**
     * @param {array} params
     * @return {Rule}
     */
    setParams(params = []) {
        this.params = params;
        return this;
    }
}

/**
 * Parse a complete scheme of rules.
 * Can contains arrays, objects and strings.
 *
 * @param {{}} ruleScheme
 * @return {{}} Parsed rules
 */
function parseScheme(ruleScheme) {
    const rules = {};

    for (let name in ruleScheme) {
        let _ruleSet = ruleScheme[name];
        let _rules = {};

        if (typeof _ruleSet === 'string') {
            _rules = parseStringRules(_ruleSet);
        } else if (Array.isArray(_ruleSet)) {
            _rules = parseArrayRules(_ruleSet);
        } else if (typeof _ruleSet === 'object') {
            _rules = parseObjectRules(_ruleSet);
        } else {
            throw `Invalid rules for ${name}`;
        }

        let isRequired = _rules['required'] !== undefined;
        let isString = _rules['string'] !== undefined;
        let isNumber = _rules['number'] !== undefined;
        let isNullable = _rules['nullable'] !== undefined;

        for (let i = 0; i < dontValidate.length; i++) {
            delete _rules[dontValidate[i]];
        }

        rules[name] = {
            rules: Object.values(_rules),
            isRequired: isRequired,
            isString: isString,
            isNumber: isNumber,
            isNullable: isNullable,
        };
    }

    return rules;
}

/**
 * @example ['required', 'max:20', someFunction ...]
 * @param {array} ruleSet
 * @return {object}
 */
function parseArrayRules(ruleSet) {
    let rules = {};
    let i = 100;
    ruleSet.map(function (rule) {
        if (rule == null || rule === '') return;

        if (typeof rule === 'string') {
            let parsedRule = parseStringRules(rule);
            Object.assign(rules, parsedRule);
        } else if (typeof rule === 'function') {
            let _ruleName = rule.name.length > 0 ? rule.name : i++;
            rules[_ruleName] = new Rule(rule);
        }
    });

    return rules;
}

/**
 * @example {required: true, in_array: [1, 2, 3, 4, 5] ... , custom: function(){}}
 * @param {object} ruleSet
 * @return {object}
 */
function parseObjectRules(ruleSet) {
    let rules = {};
    let i = 100;
    Object.keys(ruleSet).map(function (ruleName) {
        let ruleParam = ruleSet[ruleName];

        if (typeof ruleParam === 'function') {
            let _ruleName = ruleParam.name.length > 0 ? ruleParam.name : i++;
            rules[_ruleName] = new Rule(ruleParam);
        } else {
            let params = Array.isArray(ruleParam) ? ruleParam : [ruleParam];
            rules[ruleName] = new Rule(ruleName).setParams(params);
        }
    });

    return rules;
}

/**
 * @param {string} ruleSet
 * @return {object}
 */
function parseStringRules(ruleSet) {
    let rules = {};
    let allRules = ruleSet.split(ruleSeparator);

    allRules
        .filter(function (val) {
            return val !== '';
        })
        .map(function (r) {
            let _ruleParams = r.split(ruleParamSeparator);
            let _ruleName = _ruleParams[0].trim();
            let rule = new Rule(_ruleName);

            let _params = _ruleParams[1];
            let _function_params =
                _params !== undefined ? _params.split(paramsSeparator) : [];
            rule.setParams(_function_params);
            rules[_ruleName] = rule;
        });

    return rules;
}
;// CONCATENATED MODULE: ./src/Validator.js







/**
 * Extends `Validator` by adding new validation methods.
 *
 * @param {string} name
 * @param {function} method
 * @param {string|null} message
 */
function extend(name, method, message = null) {
    if (methods.hasOwnProperty(name)) {
        throw `The validation method "${name}" already exists`;
    }

    if (typeof method !== 'function') {
        throw 'The validation method must be function';
    }

    methods[name] = method;

    if (message) {
        messages[name] = message;
    }
}

/**
 * Format Validation Messages
 * @param {string} name
 * @param {object|null} params
 * @param {string} ruleName
 * @returns {string}
 */
function formatMessage(name, params, ruleName) {
    if (typeof params !== 'object') {
        params = {};
    }
    params.name = name;

    if (messages[ruleName] === undefined) {
        return defaultMessage;
    }

    let message = messages[ruleName];
    if( messages[name] !== undefined && messages[name][ruleName] !== undefined ){
        message = messages[name][ruleName];
    }

    Object.keys(params).map(function (key) {
        message = message.replace(':' + key, params[key]);
    });

    return message;
}

/**
 * Format Validation Errors
 * @param {object} errors
 * @param {object} failedRules
 * @returns {object}
 */
function formatErrors(errors, failedRules) {
    return {
        hasError: Object.keys(errors).length > 0,
        errors: errors,
        isError: function (paramName, ruleName) {
            if (ruleName === undefined) {
                return errors[paramName] !== undefined;
            } else {
                return (
                    failedRules[paramName] !== undefined &&
                    failedRules[paramName].indexOf(ruleName) !== -1
                );
            }
        },
        getError: function (paramName, getAll = true) {
            if (!Array.isArray(errors[paramName]) || errors[paramName].length === 0) {
                return '';
            }
            return getAll ? errors[paramName].join(',') : errors[paramName][0];
        },
    };
}

/**
 * Get empty Validator
 * @return {object}
 */
function getEmpty() {
    return validate({}, {});
}

/**
 * Validate given data with given rules
 *
 * @param {object} data Data to validate
 * @param {object} scheme Validation scheme
 * @param {function?} callback
 * @returns {object}
 */
function validate(data, scheme, callback) {
    let errors = {};
    let failedRules = {};

    if (typeof data !== 'object' || typeof scheme !== 'object') {
        throw 'Both data and scheme must be object';
    }

    let rules = parseScheme(scheme);

    for (let paramName in rules) {
        failedRules[paramName] = [];

        for (let i = 0, l = rules[paramName].rules.length; i < l; i++) {
            let rule = rules[paramName].rules[i];
            let result = rule.validate(rules[paramName], data[paramName], data);
            let ruleName = result.rule ? result.rule : rule.name;

            if (result === true) {
                continue;
            }

            let err;
            if (typeof result === 'string') {
                err = result;
            } else {
                err = formatMessage(paramName, result, ruleName); /// to String object => exa : paramName: name result : { min: 30 } ruleName min => message string kết quả: "Đây là min"
            }

            if (errors[paramName] === undefined) {
                errors[paramName] = [err];
            } else {
                if (errors[paramName].indexOf(err) === -1) {
                    errors[paramName].push(err);
                }
            }

            failedRules[paramName].push(ruleName);
        }
    }

    const errorHandler = formatErrors(errors, failedRules);

    if (typeof callback === 'function') {
        callback(errorHandler);
    }

    return errorHandler;
}

/***/ }),

/***/ 143:
/***/ ((module) => {

module.exports = {
  required     : ":name is required",
  min          : ":name cant be less than :min",
  max          : ":name cant be greater than :max",
  between      : ":name must be between :from and :to",
  checked      : ":name must be checked",
  array        : ":name must be array",
  object       : ":name must be object",
  boolean      : ":name must be boolean",
  numeric      : ":name can only contain digits",
  alpha_numeric: ":name can only contain digits and letters",
  alpha_dash   : ":name can only contain letters and dashes",
  alpha        : ":name can only contain leters",
  email        : ":name must be correct mail",
  phone        : ":name must be a correct phone number",
  in_array     : ":name is invalid",
  not_in       : ":name can't be :value",
  json         : ":name must be valid json",
  ip           : ":name must be valid ip adress",
  url          : ":name must be valid url",
  equals       : ":name must equal to :value",
  not_equals   : ":name can't be :value",
  contains_one : ":name must contain \":value_to_contain\"",
  contains_all : ":name must contain \":value_to_contain\"",
  starts_with  : ":name must start with :prefix",
  ends_with    : ":name must end with :suffix",
  date         : ":name must valid date",
};



// {
//   accepted: 'The :attribute must be accepted.',
//   after: 'The :attribute must be after :after.',
//   after_or_equal: 'The :attribute must be equal or after :after_or_equal.',
//   alpha: 'The :attribute field must contain only alphabetic characters.',
//   alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',
//   alpha_num: 'The :attribute field must be alphanumeric.',
//   before: 'The :attribute must be before :before.',
//   before_or_equal: 'The :attribute must be equal or before :before_or_equal.',
//   between: {
//     numeric: 'The :attribute field must be between :min and :max.',
//     string: 'The :attribute field must be between :min and :max characters.',
//   },
//   confirmed: 'The :attribute confirmation does not match.',
//   email: 'The :attribute format is invalid.',
//   date: 'The :attribute is not a valid date format.',
//   def: 'The :attribute attribute has errors.',
//   digits: 'The :attribute must be :digits digits.',
//   digits_between: 'The :attribute field must be between :min and :max digits.',
//   different: 'The :attribute and :different must be different.',
//   in: 'The selected :attribute is invalid.',
//   integer: 'The :attribute must be an integer.',
//   hex: 'The :attribute field should have hexadecimal format',
//   min: {
//     numeric: 'The :attribute must be at least :min.',
//     string: 'The :attribute must be at least :min characters.'
//   },
//   max: {
//     numeric: 'The :attribute may not be greater than :max.',
//     string: 'The :attribute may not be greater than :max characters.'
//   },
//   not_in: 'The selected :attribute is invalid.',
//   numeric: 'The :attribute must be a number.',
//   present: 'The :attribute field must be present (but can be empty).',
//   required: 'The :attribute field is required.',
//   required_if: 'The :attribute field is required when :other is :value.',
//   required_unless: 'The :attribute field is required when :other is not :value.',
//   required_with: 'The :attribute field is required when :field is not empty.',
//   required_with_all: 'The :attribute field is required when :fields are not empty.',
//   required_without: 'The :attribute field is required when :field is empty.',
//   required_without_all: 'The :attribute field is required when :fields are empty.',
//   same: 'The :attribute and :same fields must match.',
//   size: {
//     numeric: 'The :attribute must be :size.',
//     string: 'The :attribute must be :size characters.'
//   },
//   string: 'The :attribute must be a string.',
//   url: 'The :attribute format is invalid.',
//   regex: 'The :attribute format is invalid.',
//   attributes: {}
// };


/***/ }),

/***/ 514:
/***/ ((module) => {

module.exports = {
  required     : ":name bắt buộc nhập.",
  min          : ":name phải lớn hơn hoặc bằng :min.",
  max          : ":name phải nhỏ hơn hoặc bằng :max.",
  between      : ":name phải nằm trong khoảng :from và :to.",
  checked      : ":name phải được checked",
  array        : ":name phải là mảng",
  object       : ":name phải là object",
  boolean      : ":name phải là đúng/sai.",
  numeric      : ":name chỉ có thể chứa ký tự số.",
  alpha_numeric: ":name chỉ có thể chứa ký tự số và ký tự alphabet(a-z).",
  alpha_dash   : ":name chỉ có thể chứa ký tự alphabet(a-z) và dấu gạch ngang (-).",
  alpha        : ":name chỉ có thể chứa ký tự alphabet(a-z).",
  email        : ":name phải là mail hợp lệ",
  phone        : ":name phải là một số điện thoại hợp lệ.",
  in_array     : ":name chưa chính xác",
  not_in       : ":name có giá trị được chọn không hợp lệ.",
  json         : ":name phải là định dạng json",
  ip           : ":name phải là định dạng địa chỉ ip.",
  url          : ":name phải là định dạng đường dẫn url",
  equals       : ":name phải bằng :value",
  not_equals   : ":name không bằng :value",
  contains_one : ":name phải chứa \":value_to_contain\"",
  contains_all : ":name phải chứa \":value_to_contain\"",
  starts_with  : ":name phải bắt đầu bằng :prefix",
  ends_with    : ":name phải kết thúc bằng :suffix",
  date         : ":name phải là định dạng ngày tháng năm",
};












// {
//   accepted: ':attribute phải được chấp nhận.',
//   alpha: 'Trường :attribute phải là ký tự',
//   alpha_dash: ':attribute chỉ chấp nhận ký tự chữ cái, số, dấu gạch chéo và gạch dưới.',
//   alpha_num: ':attribute phải là ký tự chữ cái hoặc chữ số.',
//   between: ':attribute phải nằm trong khoảng :min và :max.',
//   confirmed: ':attribute xác nhận không trùng khớp.',
//   email: ':attribute không phải là email.',
//   date: ':attribute không phải là ngày hợp lệ',
//   def: 'Thuộc tính :attribute có lỗi.',
//   digits: ':attribute phải là số và có chiều dài bằng :digits.',
//   digits_between: 'Độ dài của trường :attribute phải nằm trong khoảng :min and :max chữ số.',
//   different: 'Giá trị của hai trường :attribute và :different phải khác nhau.',
//   in: 'Giá trị được chọn của :attribute không hợp lệ.',
//   integer: ':attribute phải là số nguyên.',
//   hex: 'The :attribute should have hexadecimal format',
//   min: {
//     numeric: ':attribute phải lớn hơn hoặc bằng :min.',
//     string: ':attribute phải có ít nhất :min ký tự.'
//   },
//   max: {
//     numeric: ':attribute phải nhỏ hơn hoặc bằng :max.',
//     string: ':attribute phải có ít hơn :max ký tự.'
//   },
//   not_in: 'Giá trị được chọn của trường :attribute không hợp lệ.',
//   numeric: ':attribute phải là số.',
//   present: 'Trường :attribute phải có mặt (nhưng có thể để trống).',
//   required: ':attribute bắt buộc nhập.',
//   required_if: ':attribute là bắt buộc khi :other có giá trị :value.',
//   same: 'Giá trị của :attribute và :same phải như nhau.',
//   size: {
//     numeric: ':attribute phải có chiều dài của bằng :size.',
//     string: 'Số ký tự của :attribute phải là :size ký tự.'
//   },
//   string: ':attribute không phải là một chuỗi',
//   url: ':attribute không phải là một Url hợp lệ.',
//   regex: ':attribute không đúng định dạng',
//   attributes: {}
// };


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
// export * as default from './Validator';


var V = __webpack_require__(572);

V.setMessages({
    name: {
        required: 'đây là reqquire',
        min: 'Đây là min'
    },
    required: 'required override message',
    min: 'validator got parameter :min and value :value'
});
V.setLocale(V.languages.vi)

const data = {
        name: "gdgfd",
    age: "hung",
    };

    const scheme = {
    name: 'required|min:30|max:35',
    age: 'numeric|min:2',
    };

    let eror = V.validate(data, scheme)
    console.log( JSON.stringify(eror), V.languages.vi ) 

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});