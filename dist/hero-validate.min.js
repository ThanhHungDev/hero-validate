(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["HeroValidate"] = factory();
	else
		root["HeroValidate"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 105:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "extend": () => (/* binding */ extend),
  "formatErrors": () => (/* binding */ formatErrors),
  "formatMessage": () => (/* binding */ formatMessage),
  "getEmpty": () => (/* binding */ getEmpty),
  "languages": () => (/* reexport */ languages),
  "setDefaultMessage": () => (/* reexport */ setDefaultMessage),
  "setLocale": () => (/* reexport */ setLocale),
  "setMessages": () => (/* reexport */ setMessages),
  "setParamsSeparator": () => (/* reexport */ setParamsSeparator),
  "setRuleParamSeparator": () => (/* reexport */ setRuleParamSeparator),
  "setRuleSeparator": () => (/* reexport */ setRuleSeparator),
  "validate": () => (/* binding */ validate)
});

// EXTERNAL MODULE: ./src/lang/en.js
var en = __webpack_require__(143);
var en_default = /*#__PURE__*/__webpack_require__.n(en);
// EXTERNAL MODULE: ./src/lang/vi.js
var vi = __webpack_require__(514);
var vi_default = /*#__PURE__*/__webpack_require__.n(vi);
;// CONCATENATED MODULE: ./src/Messages.js

let languages  = {
    // /**
    //  * lang for Arabic.
    //  */
    // ar : "ar",
    // /**
    //  * lang for Azeri.
    //  */
    // az : "az",
    // /**
    //  * lang for Belarusian.
    //  */
    // be : "be",
    // /**
    //  * lang for Bulgarian.
    //  */
    // bg : "bg",
    // /**
    //  * lang for Bosnian.
    //  */
    // bs : "bs",
    // /**
    //  * lang for Catalan.
    //  */
    // ca : "ca",
    // /**
    //  * lang for Czech.
    //  */
    // cs : "cs",
    // /**
    //  * lang for Welsh.
    //  */
    // cy : "cy",
    // /**
    //  * lang for Danish.
    //  */
    // da : "da",
    // /**
    //  * lang for German.
    //  */
    // de : "de",
    // /**
    //  * lang for Greek.
    //  */
    // el : "el",
    // /**
    //  * lang for English.
    //  */
    en : "en",
    // /**
    //  * lang for Spanish.
    //  */
    // es : "es",
    // /**
    //  * lang for Estonian.
    //  */
    // et : "et",
    // /**
    //  * lang for Basque.
    //  */
    // eu : "eu",
    // /**
    //  * lang for Farsi.
    //  */
    // fa : "fa",
    // /**
    //  * lang for Finnish.
    //  */
    // fi : "fi",
    // /**
    //  * lang for French.
    //  */
    // fr : "fr",
    // /**
    //  * lang for Croatian.
    //  */
    // hr : "hr",
    // /**
    //  * lang for Hungarian.
    //  */
    // hu : "hu",
    // /**
    //  * lang for Indonesian.
    //  */
    // id : "id",
    // /**
    //  * lang for Italian - Switzerland.
    //  */
    // it : "it",
    // /**
    //  * lang for Japanese.
    //  */
    // ja : "ja",
    // /**
    //  * lang for Georgian.
    //  */
    // ka : "ka",
    // /**
    //  * lang for Korean.
    //  */
    // ko : "ko",
    // /**
    //  * lang for Italian - Italy.
    //  */
    // It : "It",
    // Iv : "Iv",
    // /**
    //  * lang for FYRO Macedonia.
    //  */
    // mk : "mk",
    // /**
    //  * lang for Mongolian.
    //  */
    // mn : "mn",
    // /**
    //  * lang for Malay.
    //  */
    // ms : "ms",
    // /**
    //  * lang for Norwegian - Bokml.
    //  */
    // nb_NO : "nb_NO",
    // /**
    //  * lang for Dutch.
    //  */
    // nl : "nl",
    // /**
    //  * lang for Polish.
    //  */
    // pl : "pl",
    // /**
    //  * lang for Portuguese - Portugal.
    //  */
    // pt : "pt",
    // /**
    //  * lang for Portuguese - Brazil.
    //  */
    // pt_BR : "pt_BR",
    // /**
    //  * lang for Romanian.
    //  */
    // ro : "ro",
    // /**
    //  * lang for Russian.
    //  */
    // ru : "ru",
    // se : "se",
    // /**
    //  * lang for Slovenian.
    //  */
    // sl : "sl",
    // /**
    //  * lang for Albanian.
    //  */
    // sq : "sq",
    // /**
    //  * lang for Serbian.
    //  */
    // sr : "sr",
    // /**
    //  * lang for Swedish.
    //  */
    // sv : "sv",
    // /**
    //  * lang for Turkish.
    //  */
    // tr : "tr",
    // ua : "ua",
    // /**
    //  * lang for Ukrainian.
    //  */
    // uk : "uk",
    // /**
    //  * lang for Vietnamese.
    //  */
    vi : "vi",
    // /**
    //  * lang for Chinese.
    //  */
    // zh : "zh",
    // /**
    //  * lang for Chinese - Taiwan.
    //  */
    // zh_TW : "zh_TW",
}


/**
 * @type {string}
 */
let defaultMessage = 'Incorrect Value';
let defaultLocale = 'en';

/**
 * @type {*}
 */



let LANG_MESS = []
LANG_MESS[`${languages.en}`] = (en_default())
LANG_MESS[`${languages.vi}`] = (vi_default())

let messages = LANG_MESS[`${languages.en}`]


/**
 * @param {object} Message set ... 
 */
function setMessages(m) {
    if (typeof m !== 'object') {
        throw 'Messages must be object';
    }

    messages = { ...messages, ...m };
}

/**
 * @param {string} msg
 */
function setDefaultMessage(msg) {
    if (typeof msg !== 'string') {
        throw 'Default message must be a string';
    }

    defaultMessage = msg;
}


/**
 * @param {object} Message set ... 
 */
 function setLocale( locale = 'en' ) {
    if (typeof locale !== 'string') {
        throw 'Locale must be string';
    }

    defaultLocale = locale
    if( typeof LANG_MESS[locale] === undefined ){
        throw `Locale - ${locale} is not supported`;
    }
    messages = { ...messages, ...LANG_MESS[locale] };
}



;// CONCATENATED MODULE: ./src/Methods.js
const emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

let methods = {
    /**
     * @param value
     * @return {boolean|{value}}
     */
    alpha(value) {
        return /^[a-zA-Z]+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    alpha_dash(value) {
        return /^[A-Za-z\-]+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    alpha_numeric(value) {
        return /^[A-Za-z0-9]+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{}}
     */
    array(value) {
        return Array.isArray(value) || {};
    },

    /**
     * @param value
     * @param from
     * @param to
     * @return {{from, to, value}|boolean}
     */
    between(value, from, to) {
        if (typeof value === 'string') {
            if (value.length >= from && value.length <= to) {
                return true;
            }
        } else {
            if (value >= from && value <= to) {
                return true;
            }
        }
        return { from, to, value };
    },

    /**
     * @param value
     * @return {boolean}
     */
    boolean(value) {
        return typeof value === 'boolean' || {};
    },

    /**
     * @param value
     * @return {boolean}
     */
    checked(value) {
        return (
            value === 1 || value === 'on' || value === true || value === 'true' || {}
        );
    },

    /**
     * @param value
     * @param values
     * @return {{value_to_contain: *}|boolean}
     */
    contains_all(value, ...values) {
        if (!Array.isArray(value)) {
            value = String(value);
        }
        for (let i = 0, l = values.length; i < l; i++) {
            if (value.indexOf(values[i]) === -1) {
                return { value_to_contain: values[i] };
            }
        }
        return true;
    },

    /**
     * @param value
     * @param values
     * @return {boolean|{value_to_contain: string}}
     */
    contains_one(value, ...values) {
        if (!Array.isArray(value)) {
            value = String(value);
        }
        for (let i = 0, l = values.length; i < l; i++) {
            if (value.indexOf(values[i]) > -1) {
                return true;
            }
        }
        return { value_to_contain: values.join(',') };
    },

    /**
     * @param value
     * @return {boolean}
     */
    date(value) {
        return !isNaN(Date.parse(value)) || {};
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    email(value) {
        return emailRegex.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    phone(value) {
        value = String(value);
        return /^\d{7,}$/.test(value.replace(/[\s()+\-\.]|ext/gi, '')) || { value };
    },

    /**
     * @param value
     * @param suffix
     * @return {boolean|{suffix: string}}
     */
    ends_with(value, suffix) {
        suffix = String(suffix);
        value = String(value);
        return (
            value.indexOf(suffix, value.length - suffix.length) !== -1 || { suffix }
        );
    },

    /**
     * @param value
     * @param param
     * @return {boolean|{value}}
     */
    equals(value, param) {
        return String(value) === String(param) || { value: param };
    },

    /**
     * @param value
     * @param arr
     * @return {boolean|{value: string}}
     */
    in_array(value, ...arr) {
        return arr.indexOf(String(value)) > -1 || { value: arr.join(',') };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    ip(value) {
        return ipRegex.test(value) || { value };
    },

    /**
     * @param value
     * @return {{}|boolean}
     */
    json(value) {
        try {
            JSON.parse(String(value));
            return true;
        } catch (e) {
            return {};
        }
    },

    /**
     * @param value
     * @param max
     * @return {{max}|boolean}
     */
    max(value, max) {
        if (typeof value === 'string') {
            if (value.length <= max) return true;
        } else if (typeof value !== undefined) {
            if (value <= max) return true;
        }
        return { max };
    },

    /**
     * @param value
     * @param min
     * @return {{min}|boolean}
     */
    min(value, min) {
        if (typeof value === 'string') {
            if (value.length >= min) return true;
        } else if (typeof value !== undefined) {
            if (value >= min) return true;
        }
        return { min };
    },

    /**
     * @param value
     * @param param
     * @return {boolean|{value}}
     */
    not_equals(value, param) {
        return String(value) !== String(param) || { value: param };
    },

    /**
     * @param value
     * @param arr
     * @return {boolean|{value}}
     */
    not_in(value, ...arr) {
        return arr.indexOf(String(value)) === -1 || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    numeric(value) {
        return /^-?\d+$/.test(value) || { value };
    },

    /**
     * @param value
     * @return {boolean|{value}}
     */
    object(value) {
        return (typeof value === 'object' && !Array.isArray(value)) || { value };
    },

    /**
     * @param value
     * @param prefix
     * @return {boolean|{prefix: string}}
     */
    starts_with(value, prefix) {
        prefix = String(prefix);
        value = String(value);
        return value.indexOf(prefix) === 0 || { prefix };
    },

    /**
     * @param value
     * @return {{value}|boolean}
     */
    url(value) {
        try {
            new URL(value);
            return true;
        } catch (e) {
            return { value };
        }
    },
};

/**
 * @param {string} name
 * @returns {function}
 */
function getValidationMethod(name) {
    if (methods.hasOwnProperty(name) === false) {
        throw `The validation method "${name}" does not exist`;
    }
    return methods[name];
}
;// CONCATENATED MODULE: ./src/Rule.js


const dontValidate = ['required', 'string', 'nullable', 'number'];

let ruleSeparator = '|';
let ruleParamSeparator = ':';
let paramsSeparator = ',';

/**
 * Override default rule separator
 * @param {string} separator
 */
function setRuleSeparator(separator) {
    if (typeof separator !== 'string') {
        throw 'Separator must be string';
    }
    ruleSeparator = separator;
}

/**
 * Override default rule-params separator
 * @param {string} separator
 */
function setRuleParamSeparator(separator) {
    if (typeof separator !== 'string') {
        throw 'Separator must be string';
    }
    ruleParamSeparator = separator;
}

/**
 * Override default params separator
 * @param {string} separator
 */
function setParamsSeparator(separator) {
    if (typeof separator !== 'string') {
        throw 'Separator must be string';
    }
    paramsSeparator = separator;
}

/**
 * @class Rule
 * @param {string} rule
 */
class Rule {
    /**
     * @param {string|function} rule
     */
    constructor(rule) {
        if (typeof rule === 'string') {
            this.name = rule;
            this.isInlineFunction = false;
            if (dontValidate.indexOf(rule) === -1) {
                this.validator = getValidationMethod(this.name);
            }
        } else if (typeof rule === 'function') {
            this.name = rule.name || 'default';
            this.isInlineFunction = true;
            this.validator = rule;
        }

        this.params = [];
    }

    /**
     * @param {{}} rules
     * @param {*} value
     * @param {{}} data
     * @return {{rule: string}|boolean|*}
     */
    validate(rules, value, data) {
        if (value === undefined || value === null || value === '') {
            if (rules.isRequired) {
                return { rule: 'required' };
            } else if (rules.isNullable) {
                return true;
            }
        }

        if (rules.isNumber) {
            value = parseFloat(value);
        } else if (rules.isString) {
            value = String(value);
        }

        if (this.isInlineFunction) {
            return this.validator(value, data);
        } else {
            return this.validator(value, ...this.params);
        }
    }

    /**
     * @param {array} params
     * @return {Rule}
     */
    setParams(params = []) {
        this.params = params;
        return this;
    }
}

/**
 * Parse a complete scheme of rules.
 * Can contains arrays, objects and strings.
 *
 * @param {{}} ruleScheme
 * @return {{}} Parsed rules
 */
function parseScheme(ruleScheme) {
    const rules = {};

    for (let name in ruleScheme) {
        let _ruleSet = ruleScheme[name];
        let _rules = {};

        if (typeof _ruleSet === 'string') {
            _rules = parseStringRules(_ruleSet);
        } else if (Array.isArray(_ruleSet)) {
            _rules = parseArrayRules(_ruleSet);
        } else if (typeof _ruleSet === 'object') {
            _rules = parseObjectRules(_ruleSet);
        } else {
            throw `Invalid rules for ${name}`;
        }

        let isRequired = _rules['required'] !== undefined;
        let isString = _rules['string'] !== undefined;
        let isNumber = _rules['number'] !== undefined;
        let isNullable = _rules['nullable'] !== undefined;

        for (let i = 0; i < dontValidate.length; i++) {
            delete _rules[dontValidate[i]];
        }

        rules[name] = {
            rules: Object.values(_rules),
            isRequired: isRequired,
            isString: isString,
            isNumber: isNumber,
            isNullable: isNullable,
        };
    }

    return rules;
}

/**
 * @example ['required', 'max:20', someFunction ...]
 * @param {array} ruleSet
 * @return {object}
 */
function parseArrayRules(ruleSet) {
    let rules = {};
    let i = 100;
    ruleSet.map(function (rule) {
        if (rule == null || rule === '') return;

        if (typeof rule === 'string') {
            let parsedRule = parseStringRules(rule);
            Object.assign(rules, parsedRule);
        } else if (typeof rule === 'function') {
            let _ruleName = rule.name.length > 0 ? rule.name : i++;
            rules[_ruleName] = new Rule(rule);
        }
    });

    return rules;
}

/**
 * @example {required: true, in_array: [1, 2, 3, 4, 5] ... , custom: function(){}}
 * @param {object} ruleSet
 * @return {object}
 */
function parseObjectRules(ruleSet) {
    let rules = {};
    let i = 100;
    Object.keys(ruleSet).map(function (ruleName) {
        let ruleParam = ruleSet[ruleName];

        if (typeof ruleParam === 'function') {
            let _ruleName = ruleParam.name.length > 0 ? ruleParam.name : i++;
            rules[_ruleName] = new Rule(ruleParam);
        } else {
            let params = Array.isArray(ruleParam) ? ruleParam : [ruleParam];
            rules[ruleName] = new Rule(ruleName).setParams(params);
        }
    });

    return rules;
}

/**
 * @param {string} ruleSet
 * @return {object}
 */
function parseStringRules(ruleSet) {
    let rules = {};
    let allRules = ruleSet.split(ruleSeparator);

    allRules
        .filter(function (val) {
            return val !== '';
        })
        .map(function (r) {
            let _ruleParams = r.split(ruleParamSeparator);
            let _ruleName = _ruleParams[0].trim();
            let rule = new Rule(_ruleName);

            let _params = _ruleParams[1];
            let _function_params =
                _params !== undefined ? _params.split(paramsSeparator) : [];
            rule.setParams(_function_params);
            rules[_ruleName] = rule;
        });

    return rules;
}
;// CONCATENATED MODULE: ./src/Validator.js







/**
 * Extends `Validator` by adding new validation methods.
 *
 * @param {string} name
 * @param {function} method
 * @param {string|null} message
 */
function extend(name, method, message = null) {
    if (methods.hasOwnProperty(name)) {
        throw `The validation method "${name}" already exists`;
    }

    if (typeof method !== 'function') {
        throw 'The validation method must be function';
    }

    methods[name] = method;

    if (message) {
        messages[name] = message;
    }
}

/**
 * Format Validation Messages
 * @param {string} name
 * @param {object|null} params
 * @param {string} ruleName
 * @returns {string}
 */
function formatMessage(name, params, ruleName) {
    if (typeof params !== 'object') {
        params = {};
    }
    params.name = name;

    if (messages[ruleName] === undefined) {
        return defaultMessage;
    }

    let message = messages[ruleName];
    if( messages[name] !== undefined && typeof messages[name] == 'string'){
        message = messages[name];
    }
    if( messages[name] !== undefined && messages[name][ruleName] !== undefined ){
        message = messages[name][ruleName];
    }

    Object.keys(params).map(function (key) {
        message = message.replace(':' + key, params[key]);
    });

    return message;
}

/**
 * Format Validation Errors
 * @param {object} errors
 * @param {object} failedRules
 * @returns {object}
 */
function formatErrors(errors, failedRules) {
    return {
        hasError: Object.keys(errors).length > 0,
        errors: errors,
        isError: function (paramName, ruleName) {
            if (ruleName === undefined) {
                return errors[paramName] !== undefined;
            } else {
                return (
                    failedRules[paramName] !== undefined &&
                    failedRules[paramName].indexOf(ruleName) !== -1
                );
            }
        },
        getError: function (paramName, _join = ',', getAll = true) {
            if (!Array.isArray(errors[paramName]) || errors[paramName].length === 0) {
                return '';
            }
            return getAll ? errors[paramName].join(_join) : errors[paramName][0];
        },
        getAllError: function ( paramName, _join = ',' ) {
            if (!Array.isArray(errors[paramName]) || errors[paramName].length === 0) {
                return '';
            }
            return errors[paramName].join(_join)
        },
    };
}

/**
 * Get empty Validator
 * @return {object}
 */
function getEmpty() {
    return validate({}, {});
}

/**
 * Validate given data with given rules
 *
 * @param {object} data Data to validate
 * @param {object} scheme Validation scheme
 * @param {function?} callback
 * @returns {object}
 */
function validate(data, scheme, callback) {
    let errors = {};
    let failedRules = {};

    if (typeof data !== 'object' || typeof scheme !== 'object') {
        throw 'Both data and scheme must be object';
    }

    let rules = parseScheme(scheme);

    for (let paramName in rules) {
        failedRules[paramName] = [];

        for (let i = 0, l = rules[paramName].rules.length; i < l; i++) {
            let rule = rules[paramName].rules[i];
            let result = rule.validate(rules[paramName], data[paramName], data);
            let ruleName = result.rule ? result.rule : rule.name;

            if (result === true) {
                continue;
            }

            let err;
            if (typeof result === 'string') {
                err = result;
            } else {
                err = formatMessage(paramName, result, ruleName); /// to String object => exa : paramName: name result : { min: 30 } ruleName min => message string kết quả: "Đây là min"
            }

            if (errors[paramName] === undefined) {
                errors[paramName] = [err];
            } else {
                if (errors[paramName].indexOf(err) === -1) {
                    errors[paramName].push(err);
                }
            }

            failedRules[paramName].push(ruleName);
        }
    }

    const errorHandler = formatErrors(errors, failedRules);

    if (typeof callback === 'function') {
        callback(errorHandler);
    }

    return errorHandler;
}

/***/ }),

/***/ 143:
/***/ ((module) => {

module.exports = {
    required     : ":name is required",
    min          : ":name cant be less than :min",
    max          : ":name cant be greater than :max",
    between      : ":name must be between :from and :to",
    checked      : ":name must be checked",
    array        : ":name must be array",
    object       : ":name must be object",
    boolean      : ":name must be boolean",
    numeric      : ":name can only contain digits",
    alpha_numeric: ":name can only contain digits and letters",
    alpha_dash   : ":name can only contain letters and dashes",
    alpha        : ":name can only contain leters",
    email        : ":name must be correct mail",
    phone        : ":name must be a correct phone number",
    in_array     : ":name is invalid",
    not_in       : ":name can't be :value",
    json         : ":name must be valid json",
    ip           : ":name must be valid ip adress",
    url          : ":name must be valid url",
    equals       : ":name must equal to :value",
    not_equals   : ":name can't be :value",
    contains_one : ":name must contain \":value_to_contain\"",
    contains_all : ":name must contain \":value_to_contain\"",
    starts_with  : ":name must start with :prefix",
    ends_with    : ":name must end with :suffix",
    date         : ":name must valid date",
};

/***/ }),

/***/ 514:
/***/ ((module) => {

module.exports = {
    required     : ":name bắt buộc nhập.",
    min          : ":name phải lớn hơn hoặc bằng :min.",
    max          : ":name phải nhỏ hơn hoặc bằng :max.",
    between      : ":name phải nằm trong khoảng :from và :to.",
    checked      : ":name phải được checked",
    array        : ":name phải là mảng",
    object       : ":name phải là object",
    boolean      : ":name phải là đúng/sai.",
    numeric      : ":name chỉ có thể chứa ký tự số.",
    alpha_numeric: ":name chỉ có thể chứa ký tự số và ký tự alphabet(a-z).",
    alpha_dash   : ":name chỉ có thể chứa ký tự alphabet(a-z) và dấu gạch ngang (-).",
    alpha        : ":name chỉ có thể chứa ký tự alphabet(a-z).",
    email        : ":name phải là mail hợp lệ",
    phone        : ":name phải là một số điện thoại hợp lệ.",
    in_array     : ":name chưa chính xác",
    not_in       : ":name có giá trị được chọn không hợp lệ.",
    json         : ":name phải là định dạng json",
    ip           : ":name phải là định dạng địa chỉ ip.",
    url          : ":name phải là định dạng đường dẫn url",
    equals       : ":name phải bằng :value",
    not_equals   : ":name không bằng :value",
    contains_one : ":name phải chứa \":value_to_contain\"",
    contains_all : ":name phải chứa \":value_to_contain\"",
    starts_with  : ":name phải bắt đầu bằng :prefix",
    ends_with    : ":name phải kết thúc bằng :suffix",
    date         : ":name phải là định dạng ngày tháng năm",
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
// export * as default from './Validator';




var V = __webpack_require__(105);



const message = {
    password: ":name failure...",
    mycustom: "try turn off mycustom"
}

V.setMessages(message);
V.setLocale(V.languages.vi)

const data = {
    password: 'hungfff',
    confirm_password: "fdsfds",
    
}

/// create rule for your form
const rules = {
    password     : "required|min:7|max:100",
    confirm_password : {
        required: true,
        mycustom: function (value) {
            if (value !== data.password) {
                return {}; /// try return {}
            }
            return true;
        },
    },
};

let result = V.validate(data,  rules)
console.log( JSON.stringify(result)  ) 


})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});